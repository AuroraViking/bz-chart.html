<script>
  const canvas = document.getElementById('bzChart');
  const bzInfo = document.getElementById('bzInfo');
  const auroraMessage = document.getElementById('auroraMessage');

  // Create Kp display elements dynamically
  const kpInfo = document.createElement("div");
  const kpMessage = document.createElement("div");
  kpInfo.id = "kpInfo";
  kpMessage.id = "kpMessage";
  kpInfo.style.fontSize = "1.1rem";
  kpMessage.style.fontSize = "1.3rem";
  kpMessage.style.fontWeight = "bold";
  kpMessage.style.marginBottom = "12px";
  document.body.insertBefore(kpInfo, document.querySelector(".chart-container"));
  document.body.insertBefore(kpMessage, document.querySelector(".chart-container"));

  let chart;
  let lastRange = "";

  async function fetchBzData() {
    try {
      const response = await fetch('https://services.swpc.noaa.gov/products/solar-wind/mag-2-hour.json');
      const data = await response.json();
      const rows = data.slice(1).filter(row => !isNaN(parseFloat(row[3])));
      const times = rows.map(row => row[0].slice(11, 16));
      const bzValues = rows.map(row => parseFloat(row[3]));
      return { times, bzValues };
    } catch (err) {
      console.error("Failed to fetch or parse Bz data:", err);
      bzInfo.textContent = "Error fetching Bz data.";
      return { times: [], bzValues: [] };
    }
  }

  async function fetchKpData() {
    try {
      const response = await fetch("https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json");
      const data = await response.json();
      const latest = data[data.length - 1];
      const kp = parseInt(latest[1]);
      return kp;
    } catch (err) {
      console.error("Failed to fetch Kp index:", err);
      kpInfo.textContent = "Error fetching Kp index.";
      return null;
    }
  }

  function getKpMessage(kp) {
    if (kp === 1) return "Aurora low to the north";
    if (kp === 2) return "Aurora to the north";
    if (kp === 3) return "Aurora to the north";
    if (kp === 4) return "Aurora to the North and Overhead";
    if (kp === 5) return "Aurora to the North and Overhead";
    if (kp === 6) return "Aurora to the North, Overhead and South";
    if (kp === 7) return "Aurora to the North, Overhead and South";
    if (kp === 8) return "Aurora to the North, Overhead and South";
    if (kp === 9) return "ðŸŒŒ Aurora everywhere â€” letâ€™s dance to the disco lights!";
    return "Kp index not available";
  }

  function calculateBzH(bzValues) {
    let bzH = 0;
    for (let bz of bzValues) {
      if (bz < 0) bzH += (-bz * (1 / 60));
    }
    return parseFloat(bzH.toFixed(2));
  }

  function getAuroraMessage(bzH) {
    if (bzH > 0 && bzH <= 1.5) return "Weak aurora possible in the next hours";
    if (bzH > 1.5 && bzH <= 3) return "Faint aurora likely in the next few hours";
    if (bzH > 3 && bzH <= 4.5) return "Moderate aurora likely in the next few hours";
    if (bzH > 4.5 && bzH <= 6) return "Strong aurora likely in the next few hours";
    if (bzH > 6) return "ðŸŒŒ Strong aurora conditions, get out now!";
    return "No aurora potential right now";
  }

  function getYAxisRange(bzValues) {
    const min = Math.min(...bzValues);
    const max = Math.max(...bzValues);
    if (min >= -5 && max <= 5) return { yMin: -5, yMax: 5, tag: "tight" };
    if (min >= -10 && max <= 10) return { yMin: -10, yMax: 10, tag: "medium" };
    return { yMin: -100, yMax: 100, tag: "wide" };
  }

  function drawChart(times, bzValues, yMin, yMax) {
    if (chart) chart.destroy();
    chart = new Chart(canvas.getContext('2d'), {
      type: 'line',
      data: {
        labels: times,
        datasets: [{
          label: 'IMF Bz (nT)',
          data: bzValues,
          fill: true,
          borderColor: 'white',
          pointRadius: 0,
          hitRadius: 0,
          hoverRadius: 0,
          tension: 0.3,
          backgroundColor: function(context) {
            const chart = context.chart;
            const {ctx, chartArea} = chart;
            if (!chartArea) return 'rgba(255,255,255,0.1)';
            const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.3)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)');
            return gradient;
          },
          segment: {
            borderColor: ctx => ctx.p0.parsed.y < 0 ? 'gold' : 'white',
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: { color: 'white' },
            grid: { color: 'gray' }
          },
          y: {
            min: yMin,
            max: yMax,
            ticks: { stepSize: 10, color: 'white' },
            grid: { color: 'gray' }
          }
        },
        plugins: {
          legend: { labels: { color: 'white' } }
        }
      }
    });
  }

  async function updateChart() {
    const { times, bzValues } = await fetchBzData();
    const kp = await fetchKpData();
    if (bzValues.length === 0 || kp === null) return;

    const bzH = calculateBzH(bzValues);
    const bzMessage = getAuroraMessage(bzH);
    const kpMessageText = getKpMessage(kp);
    const { yMin, yMax, tag } = getYAxisRange(bzValues);

    bzInfo.textContent = `Current -BzH (2hr): ${bzH}`;
    auroraMessage.textContent = bzMessage;
    auroraMessage.className = bzH > 4.5 ? "aurora-strong" : "";

    kpInfo.textContent = `Kp index: ${kp}`;
    kpMessage.textContent = kpMessageText;

    if (!chart || lastRange !== tag) {
      drawChart(times, bzValues, yMin, yMax);
      lastRange = tag;
    } else {
      chart.data.labels = times;
      chart.data.datasets[0].data = bzValues;
      chart.update();
    }
  }

  updateChart();
  setInterval(updateChart, 5 * 60 * 1000);
</script>
